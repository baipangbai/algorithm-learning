# 简单的例子

## 递归原理

[字符串反转](https://leetcode-cn.com/leetbook/read/recursion/490ye/)

```go
//递归实现，可以直接换算成用一个for循环实现
func reverseString(s []byte) {
  helper(0, len(s)-1, s)
}
func helper(start, end int, s [] byte) {
  if start >= end {
    return
  }
  tmp := s[end]
  s[end] = s[start]
  s[start] = tmp
  helper(start+1, end-1, s)
}
```

尾递归：若函数在尾位置调用自身，则这种情况称为尾递归。

公式：将问题定义为有待实现的函数F(X)，其中X是函数的输入，同时也定义了问题的范围。然后在F(X)中实现

1. 将问题逐步分解成较小的范围，例如 *x*0∈*X*, x1∈X{x_1} \in X*x*1∈*X*, ..., xn∈X{x_n} \in X*x**n*∈*X*；
2. 调用函数*F*(*x*0), F(x1), ..., F(xn)递归的解决问题
3. 最后处理调用递归函数得到的结果来解决对应的X的问题

## 递推关系

1. 杨辉三角	
   1. *f*(*i*,*j*)=*f*(*i*−1,*j*−1)+*f*(*i*−1,*j*)
   2. 可以看到，每行的最左边和最右边的数字是`基本情况`，在这个问题中，它总是等于 1。*f*(*i*, *i*)=1 *f*(*i*, *0*)=1 

```go
func generate(numRows int) [][]int {
    res := make([][]int, numRows)
    for i := range res {
        res[i] = make([]int, i+1)
        res[i][0] = 1
        res[i][i] = 1
        for j := 1; j < i; j++ {
            res[i][j] = res[i-1][j] + res[i-1][j-1]
        }
    }
    return res
}
```



存在优化空间：里面涉及到重复计算的问题：比如计算*f*(*5*,*3*) = *f*(*4*, *3*) + *f*(*4*, *2*)

*f*(4,2)=*f*(3,1)+ *f*(3,2) =*f*(3,1)+(*f*(2,1)+*f*(2,2))=1+(1+1)=3

 *f*(4,3)=*f*(3,2) + *f*(3,3) =(*f*(2,1)+*f*(2,2))+*f*(3,3)=(1+1)+1=3

结果： *f*(5,3)=*f*(4,2)+*f*(4,3)=3+3=6

重复计算的部分：*f*(3,2)

怎么优化？

注意i+1行的计算，仅用到了i行的数据。所以可以优化成。**滚动数组** 动态规划经常会用到

```go
//返回杨辉三角的第K行
func getRow(numRows int) []int {
  var pre, cur []int

  //要有等于号
  for i := 0; i <= numRows; i++ {
    cur = make([]int, i+1)
    cur[0] = 1
    cur[i] = 1
    for j := 1; j < i; j++ {
      cur[j] = pre[j] + pre[j-1]
    }
    pre = cur
  }
  return pre
}
```

2. 反转链表： 

   输入: 1->2->3->4->5->NULL

   输出: 5->4->3->2->1->NULL

```go
//非递归
func reverseList(head *ListNode) *ListNode {
  if head == nil {
    return nil
  }
  var prev *ListNode
  cur := head
  for cur != nil {
    next := cur.Next
    cur.Next = prev
    prev = cur
    cur = next
  }
  return prev
}
//递归，假设链表为 n1 →…→nk−1 →nk →nk+1 →…→nm →∅，其中nk+1到nm都已经发生反转（n1 →…→nk−1 →nk →nk+1 ←…←nm），我们处于nk，希望nk+1的下一个节点指向nk，所以nk.next.next = nk（需要注意的是：n1的下一个节点必须指向nil）

func reverse(head *ListNode) *ListNode {
  if head == nil || head.Next == nil {
    return head
  }
  newHead := reverse(head.Next)
  head.Next.Next = head
  head.Next = nil
  return newHead
}

```

## memorization（记忆化）技术

递归中容易出现重复计算的问题，该主题下就是针对该方法做的方案。

1. 构造一个map存储中间数组
2. 滚动数组





